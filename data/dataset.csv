
ï»¿prompt,completion
throw an error in non production environments,"if (process.env.NODE_ENV !== 'production') {
    throw new Error(`take(patternOrChannel): argument ${patternOrChannel} is not valid channel or a valid pattern`)
  }"
"in non prod, check to see if the argument is a fork","if (process.env.NODE_ENV !== 'production') {
    check(eff, isForkEffect, 'detach(eff): argument must be a fork effect')
  }"
non prod check if pattern or channel is undefined,"if (process.env.NODE_ENV !== 'production' && arguments.length) {
    check(arguments[0], is.notUndef, 'take(patternOrChannel): patternOrChannel is undefined')
  }"
"check that channel argument is set and is valid, check that action is defined and is valid","if (process.env.NODE_ENV !== 'production') {
    if (arguments.length > 1) {
      check(channel, is.notUndef, 'put(channel, action): argument channel is undefined')
      check(channel, is.channel, `put(channel, action): argument ${channel} is not a valid channel`)
      check(action, is.notUndef, 'put(channel, action): argument action is undefined')
    } else {
      check(channel, is.notUndef, 'put(action): argument action is undefined')
    }
  }"
"in staging environment, check that argument is a fork effect","if (process.env.NODE_ENV !== 'production') {
    check(eff, isForkEffect, 'detach(eff): argument must be a fork effect')
  }"
"in non prod, with arguments, check that pattern or channel is defined","if (process.env.NODE_ENV !== 'production' && arguments.length) {
    check(arguments[0], is.notUndef, 'take(patternOrChannel): patternOrChannel is undefined')
  }"
"in non prod, with 2 args, channel and action both are valid, with one arg, action is valid","if (process.env.NODE_ENV !== 'production') {
    if (arguments.length > 1) {
      check(channel, is.notUndef, 'put(channel, action): argument channel is undefined')
      check(channel, is.channel, `put(channel, action): argument ${channel} is not a valid channel`)
      check(action, is.notUndef, 'put(channel, action): argument action is undefined')
    } else {
      check(channel, is.notUndef, 'put(action): argument action is undefined')
    }
  }"
"in test environment, check that argument is a fork","if (process.env.NODE_ENV !== 'production') {
    check(eff, isForkEffect, 'detach(eff): argument must be a fork effect')
  }"
"in local development environment, check that argument is a fork effect","if (process.env.NODE_ENV !== 'production') {
    check(eff, isForkEffect, 'detach(eff): argument must be a fork effect')
  }"
"when there's one arg, check that action is defined and valid","if (process.env.NODE_ENV !== 'production') {
    if (arguments.length > 1) {
      check(channel, is.notUndef, 'put(channel, action): argument channel is undefined')
      check(channel, is.channel, `put(channel, action): argument ${channel} is not a valid channel`)
      check(action, is.notUndef, 'put(channel, action): argument action is undefined')
    } else {
      check(channel, is.notUndef, 'put(action): argument action is undefined')
    }
  }"
"when there are two args, check that channel and action arguments are defined and valid, channel is first argument, action is second argument","if (process.env.NODE_ENV !== 'production') {
    if (arguments.length > 1) {
      check(channel, is.notUndef, 'put(channel, action): argument channel is undefined')
      check(channel, is.channel, `put(channel, action): argument ${channel} is not a valid channel`)
      check(action, is.notUndef, 'put(channel, action): argument action is undefined')
    } else {
      check(channel, is.notUndef, 'put(action): argument action is undefined')
    }
  }"
"define function for apply effect, in non prod validate that the function descriptor is apply, return result of make effect","export function apply(context, fn, args = []) {
  const fnDescriptor = [context, fn]

  if (process.env.NODE_ENV !== 'production') {
    validateFnDescriptor('apply', fnDescriptor)
  }

  return makeEffect(effectTypes.CALL, getFnCallDescriptor([context, fn], args))
}"
"define function for fork effect, in non prod validate that the function descriptor is fork, check that argument is not an effect, and return result of make effect","export function fork(fnDescriptor, ...args) {
  if (process.env.NODE_ENV !== 'production') {
    validateFnDescriptor('fork', fnDescriptor)

    check(fnDescriptor, (arg) => !is.effect(arg), 'fork: argument must not be an effect')
  }
  return makeEffect(effectTypes.FORK, getFnCallDescriptor(fnDescriptor, args))
}"
"finite state machine iterator function that takes a start state and a name and moves to the next state using a state updater function, returning an iterator","export default function fsmIterator(fsm, startState, name) {
  let stateUpdater,
    errorState,
    effect,
    nextState = startState

  function next(arg, error) {
    if (nextState === qEnd) {
      return done(arg)
    }
    if (error && !errorState) {
      nextState = qEnd
      throw error
    } else {
      stateUpdater && stateUpdater(arg)
      const currentState = error ? fsm[errorState](error) : fsm[nextState]()
      ;({ nextState, effect, stateUpdater, errorState } = currentState)
      return nextState === qEnd ? done(arg) : effect
    }
  }

  return makeIterator(next, (error) => next(null, error), name)
}"
"if there's an error and we're not already in an error state, go to the end state and throw the error","    if (error && !errorState) {
      nextState = qEnd
      throw error
    }"
function that returns the name of a pattern or channel,"export function safeName(patternOrChannel) {
  if (is.channel(patternOrChannel)) {
    return 'channel'
  }

  if (is.stringableFunc(patternOrChannel)) {
    return String(patternOrChannel)
  }

  if (is.func(patternOrChannel)) {
    return patternOrChannel.name
  }

  return String(patternOrChannel)
}"
return the name of a pattern or channel,"if (is.func(patternOrChannel)) {
    return patternOrChannel.name
  }"
debounce function for redux saga action,"export default function debounceHelper(delayLength, patternOrChannel, worker, ...args) {
  let action, raceOutput

  const yTake = { done: false, value: take(patternOrChannel) }
  const yRace = {
    done: false,
    value: race({
      action: take(patternOrChannel),
      debounce: delay(delayLength),
    }),
  }
  const yFork = (ac) => ({ done: false, value: fork(worker, ...args, ac) })
  const yNoop = (value) => ({ done: false, value })

  const setAction = (ac) => (action = ac)
  const setRaceOutput = (ro) => (raceOutput = ro)

  return fsmIterator(
    {
      q1() {
        return { nextState: 'q2', effect: yTake, stateUpdater: setAction }
      },
      q2() {
        return { nextState: 'q3', effect: yRace, stateUpdater: setRaceOutput }
      },
      q3() {
        return raceOutput.debounce
          ? { nextState: 'q1', effect: yFork(action) }
          : { nextState: 'q2', effect: yNoop(raceOutput.action), stateUpdater: setAction }
      },
    },
    'q1',
    `debounce(${safeName(patternOrChannel)}, ${worker.name})`,
  )
}"
effect for taking a value from a pattern,"const yTake = { done: false, value: take(patternOrChannel) }"
effect for taking a value from a channel,"const yTake = { done: false, value: take(patternOrChannel) }"
no op effect,"const yNoop = (value) => ({ done: false, value })"
noop effect,"const yNoop = (value) => ({ done: false, value })"
effect that does nothing,"const yNoop = (value) => ({ done: false, value })"
import deferred,import deferred from '@redux-saga/deferred'
import deferred,import { arrayOfDeferred } from '@redux-saga/deferred'
import deferred,"import deferred, { arrayOfDeferred } from '@redux-saga/deferred'"
create deferred promise,const def = deferred()
defer promise,const def = deferred()
defer a set of promises,const defs = arrayOfDeferred(2)
defer a list of promises,const defs = arrayOfDeferred(2)
defer an array of promises,const defs = arrayOfDeferred(2)
defer promises list,const defs = arrayOfDeferred(2)
run saga through redux store,"const middleware = sagaMiddleware()
createStore(() => ({}), {}, applyMiddleware(middleware))
Promise.resolve(1)
    .then(() => defs[0].reject('error'))
    .then(() => defs[1].resolve(1))

  function* genFn() {
    try {
      actual = yield io.all([defs[0].promise, defs[1].promise])
    } catch (err) {
      actual = [err]
    }
  }

  const task = middleware.run(genFn)"
test empty array saga,"test('saga empty array', () => {
  let actual
  const middleware = sagaMiddleware()
  createStore(() => ({}), {}, applyMiddleware(middleware))